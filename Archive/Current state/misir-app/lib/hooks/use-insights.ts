/**
 * useInsights Hook
 * 
 * Data-fetching hook for insights using SWR.
 * Insights are stored in Supabase (generated by backend or engine).
 */

import useSWR from 'swr';
import { useCallback } from 'react';
import { defaultSwrOptions } from './swr-config';
import { createBrowserClient } from '@supabase/ssr';
import type { InsightAction } from '@/lib/types';

interface InsightData {
    id: string;
    type: string;
    title: string;
    description: string;
    priority: number;
    status: 'active' | 'dismissed' | 'kept' | 'crystallized';
    space_id: string | null;
    created_at: string;
    evidence: Record<string, unknown>;
}

interface UseInsightsOptions {
    /** Only fetch active insights */
    activeOnly?: boolean;
    /** Disable fetching */
    enabled?: boolean;
}

/**
 * Supabase fetcher for insights
 */
async function insightsFetcher(key: string): Promise<InsightData[]> {
    const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );
    
    // Parse key: "insights:active" or "insights:all"
    const [, filter] = key.split(':');
    const activeOnly = filter === 'active';
    
    let query = supabase
        .from('insights')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(50);
    
    if (activeOnly) {
        query = query.eq('status', 'active');
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data || [];
}

/**
 * Fetch insights for the current user.
 */
export function useInsights(options: UseInsightsOptions = {}) {
    const { activeOnly = true, enabled = true } = options;

    const key = enabled
        ? `insights:${activeOnly ? 'active' : 'all'}`
        : null;

    const { data, error, isLoading, mutate } = useSWR<InsightData[]>(
        key,
        insightsFetcher,
        defaultSwrOptions
    );

    /**
     * Perform an action on an insight (dismiss, keep, crystallize).
     * Uses optimistic updates.
     */
    const performAction = useCallback(async (insightId: string, action: InsightAction) => {
        const supabase = createBrowserClient(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
        );
        
        // Optimistic update
        const optimisticData = (data || []).filter(i => i.id !== insightId);
        await mutate(optimisticData, false);

        try {
            const status = action === 'dismiss' ? 'dismissed' 
                : action === 'keep' ? 'kept' 
                : 'crystallized';
            
            const { error } = await supabase
                .from('insights')
                .update({ 
                    status,
                    actioned_at: new Date().toISOString()
                })
                .eq('id', insightId);

            if (error) throw error;

            // Revalidate
            await mutate();
        } catch (err) {
            // Rollback on error
            await mutate();
            throw err;
        }
    }, [data, mutate]);

    /**
     * Trigger insight generation (calls backend).
     * For now, this is a no-op until backend implements insight generation.
     */
    const generateInsights = useCallback(async () => {
        // TODO: Call backend to generate insights
        // await backendApi.insights.generate();
        console.log('[Insights] Backend insight generation not yet implemented');
        await mutate();
    }, [mutate]);

    return {
        insights: data || [],
        isLoading,
        isError: !!error,
        error,
        refresh: mutate,
        performAction,
        generateInsights,
    };
}

/**
 * Get count of active insights.
 */
export function useInsightCount() {
    const { insights, isLoading } = useInsights({ activeOnly: true });

    return {
        count: insights.length,
        isLoading,
    };
}
